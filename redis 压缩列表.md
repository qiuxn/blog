# 压缩列表数据结构

## 1.运用

redis中的list和hash均采用ziplist

## 2.压缩列表数据结构

| 组成部分 | `zlbytes`                  | `zltail`                       | `zllen`     | `entry1` | `entry2` | ...  | `entryN` | `zlend`            |
| -------- | :------------------------- | ------------------------------ | ----------- | -------- | -------- | ---- | -------- | ------------------ |
| 解释     | 整个压缩列表所占用的字节数 | 最后一个元素到起始位置的偏移量 | 节点个数N   | 节点1    | 节点2    |      | 节点N    | 压缩列表的结束标志 |
| 类型     | int  4个字节               | int  4个字节                   | int 2个字节 |          |          |      |          | int 1个字节        |



![压缩列表](C:\Users\Administrator\Desktop\压缩列表.png)

## 3.压缩列表节点数据结构

| 组成部分 | `previous_entry_length`   | `encoding`                       | `content`                                  |
| -------- | ------------------------- | -------------------------------- | ------------------------------------------ |
| 解释     | 前一节点的长度（字节数）  | 编码类型，记录了数据长度和类型。 | 节点的值。节点值可以是一个字节数组或者整数 |
| 类型     | int  （1个字节或5个字节） |                                  |                                            |

![img](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png)

encodeing表示数据长度和类型

eg: 00001011，00表示字符串，001011表示13位字符串，对应content="Hello World"

eg: 11000000，表示整数，占位2个字节，00100111  01100110    =10086

1、00xxxxxx 最大长度位 63 的短字符串，后面的 6 个位存储字符串的位数，剩余的字
节就是字符串的内容。
 2、01xxxxxx xxxxxxxx 中等长度的字符串，后面 14 个位来表示字符串的长度，剩余的
字节就是字符串的内容。
 3、10000000 aaaaaaaa bbbbbbbb cccccccc dddddddd 特大字符串，需要使用额外 4 个字节
来表示长度。第一个字节前缀是 10，剩余 6 位没有使用，统一置为零。后面跟着字符串内
容。不过这样的大字符串是没有机会使用的，压缩列表通常只是用来存储小数据的。
 4、11000000 表示 int16，后跟两个字节表示整数。
 5、11010000 表示 int32，后跟四个字节表示整数。
 6、11100000 表示 int64，后跟八个字节表示整数。
 7、11110000 表示 int24，后跟三个字节表示整数。
 8、11111110 表示 int8，后跟一个字节表示整数。
 9、11111111 表示 ziplist 的结束，也就是 zlend 的值 0xFF

## 4.连锁更新

prevlen表示前一节点的字节长度，如果内容小于254字节，那么prevlen用一个字节存储，假设前一个节点修改之后，大于254，那么prelen会变成5个字节，假设当前节点为254个节点，那么引起下一个节点跟新prelen。如此就有可能出现：更新某一个节点，导致列表中的每一个节点更新



删除某个节点也会引发连锁更新！

eg:   entry 1()----entry2(254个字节)---entry3(删除的元素，原来占10个字节)--entry4

此时entry3,那么entry的prevlen,原来本来时1个字节，然后由于entry2长度>254,那么entry的prevlen必然扩容



## 5.遍历

### 5.1正向遍历

- 将 P 指针指向头节点的首地址
- 获取当前迭代节点的长度。通过编码获取
- 下一个节点。通过 P + 迭代节点长度，将 P 指针移动到下一个节点
- 迭代结束标志。遇到末端标识符时，结束迭代

### 5.2逆向遍历

- 起始节点（P点）指向尾节点
- 获取当前节点的前置节点长度值
- 移动到前一个节点的首地址，通过（P + 前置节点长度值）来移动
- 迭代结束标志。当前置节点长度值为 0，代表无前置节点了



